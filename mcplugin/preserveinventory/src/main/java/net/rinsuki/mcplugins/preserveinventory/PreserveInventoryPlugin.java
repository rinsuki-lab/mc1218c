/*
 * This source file was generated by the Gradle 'init' task
 */
package net.rinsuki.mcplugins.preserveinventory;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.bukkit.event.player.PlayerRespawnEvent;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.event.entity.PlayerDeathEvent;
import org.bukkit.event.entity.ItemSpawnEvent;
import org.bukkit.event.inventory.PrepareItemCraftEvent;
import org.bukkit.event.inventory.CraftItemEvent;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.Location;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.inventory.meta.BookMeta;

import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.JoinConfiguration;
import net.kyori.adventure.text.event.ClickEvent;
import net.kyori.adventure.text.event.HoverEvent;
import net.kyori.adventure.text.format.NamedTextColor;
import net.kyori.adventure.text.format.TextDecoration;

import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.World;
import org.bukkit.entity.Item;
import org.bukkit.persistence.PersistentDataContainer;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.event.player.PlayerDropItemEvent;
import net.kyori.adventure.key.Key;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

public class PreserveInventoryPlugin extends JavaPlugin implements Listener {
    private File playersDir;
    private final Map<UUID, PlayerState> instances = new HashMap<>();
    private NamespacedKey keyRecordDeathId;
    private NamespacedKey keyRecordOwner;

    @Override
    public void onEnable() {
        // Ensure data folder exists and initialize per-player state directory
        getDataFolder().mkdirs();
        playersDir = new File(getDataFolder(), "players");
        playersDir.mkdirs();
        // Register event listeners
        getServer().getPluginManager().registerEvents(this, this);

        // Prepare PDC keys for "遺留品の記録"
        keyRecordDeathId = new NamespacedKey(this, "recordDeathId");
        keyRecordOwner = new NamespacedKey(this, "recordOwner");
    }

    private synchronized PlayerState getPlayerState(Player player) {
        UUID uuid = player.getUniqueId();
        return instances.computeIfAbsent(uuid, id -> new PlayerState(id, playersDir, getLogger()));
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (!"preserveinventory".equalsIgnoreCase(command.getName())) {
            return false;
        }

        if (!(sender instanceof Player)) {
            sender.sendMessage("このコマンドはプレイヤーのみが実行できます。");
            return true;
        }

        Player player = (Player) sender;

        if (args.length == 0) {
            boolean enabled = getPlayerState(player).isEnabled();
            player.sendMessage(enabled ? "PreserveInventoryが有効になっています。" : "PreserveInventoryが無効になっています。");
            player.sendMessage("/" + label + " on | off で切り替えできます。");
            player.sendMessage("/" + label + " list で保存済みの死亡記録を表示します。");
            player.sendMessage("/" + label + " take <deathId> で保存済みのアイテムを取り出します。");
            return true;
        }

        String sub = args[0].toLowerCase();
        switch (sub) {
            case "on":
                getPlayerState(player).setEnabled(true);
                player.sendMessage("PreserveInventoryを有効にしました。");
                return true;
            case "off":
                getPlayerState(player).setEnabled(false);
                player.sendMessage("PreserveInventoryを無効にしました。");
                return true;
            case "list":
                {
                    List<PlayerState.DeathSummary> list = getPlayerState(player).listDeaths();
                    if (list.isEmpty()) {
                        player.sendMessage("保存済みの死亡記録はありません。");
                    } else {
                        for (int i = 0; i < list.size(); i++) {
                            PlayerState.DeathSummary s = list.get(i);
                            String ts = formatTimestamp(s.createdAt);
                            String header = String.format("%s に死亡 @ %s x%d y%d z%d", ts, s.world, Math.round(s.x), Math.round(s.y), Math.round(s.z));
                            Component line1 = Component.text(header).color(NamedTextColor.AQUA);
                            player.sendMessage(line1);

                            Component itemsComp = summarizeDropsComponent(s.drops);

                            // Show cost summary first (with hover item info)
                            PlayerState.Cost c = PlayerState.computeCost(s.drops);
                            Component costComp;
                            if (c.diamond > 0) {
                                costComp = Component.text("コスト: ", NamedTextColor.GOLD)
                                    .append(itemStackToComponent(new ItemStack(Material.DIAMOND, c.diamond)));
                            } else if (c.iron > 0) {
                                costComp = Component.text("コスト: ", NamedTextColor.GOLD)
                                    .append(itemStackToComponent(new ItemStack(Material.IRON_INGOT, c.iron)));
                            } else {
                                costComp = Component.text("コスト: なし", NamedTextColor.GOLD);
                            }

                            Component btn = Component.text("[受け取る]")
                                .color(NamedTextColor.GREEN)
                                .decorate(TextDecoration.BOLD)
                                .clickEvent(ClickEvent.runCommand("/" + label + " take " + s.deathId))
                                .hoverEvent(HoverEvent.showText(Component.text("クリックして受け取る: " + s.deathId).color(NamedTextColor.YELLOW)));

                            Component info = Component.empty()
                                .append(costComp)
                                .append(Component.text("  アイテム: ", NamedTextColor.GRAY))
                                .append(itemsComp.colorIfAbsent(NamedTextColor.GRAY));

                            // Send as siblings so only [受け取る] is clickable
                            player.sendMessage(Component.empty().append(btn).append(info));

                            if (i < list.size() - 1) {
                                player.sendMessage("");
                            }
                        }
                    }
                    return true;
                }
            case "take":
                {
                    if (args.length < 2) {
                        player.sendMessage("使い方: /" + label + " take <deathId>");
                        return true;
                    }
                    String deathIdArg = args[1];
                    PlayerState state = getPlayerState(player);
                    PlayerState.Cost cost = state.getDeathCost(deathIdArg);
                    if (cost == null) {
                        // No death entry found. If the player has the matching record and a refund exists, process refund.
                        if (hasRecordFor(player, deathIdArg)) {
                            ItemStack refund = state.takeRefund(deathIdArg);
                            if (refund != null) {
                                // Consume the record and give back the paid items
                                consumeRecordFor(player, deathIdArg);
                                Map<Integer, ItemStack> leftover = player.getInventory().addItem(refund);
                                if (!leftover.isEmpty()) {
                                    for (ItemStack remain : leftover.values()) {
                                        if (remain == null) continue;
                                        player.getWorld().dropItemNaturally(player.getLocation(), remain);
                                    }
                                }
                                Component msg = Component.text("記録を使用し、支払った ")
                                    .append(itemStackToComponent(refund))
                                    .append(Component.text(" を返還しました。", NamedTextColor.GRAY));
                                player.sendMessage(msg);
                                return true;
                            }
                        }
                        player.sendMessage("該当する死亡記録が見つかりません: " + deathIdArg);
                        return true;
                    }
                    // If player holds a matching record, consume it and waive cost
                    boolean usedRecord = false;
                    if (hasRecordFor(player, deathIdArg)) {
                        usedRecord = consumeRecordFor(player, deathIdArg);
                    }

                    // Determine required payment (diamond has priority rule)
                    int needDiamond = usedRecord ? 0 : cost.diamond;
                    int needIron = usedRecord ? 0 : ((needDiamond > 0) ? 0 : cost.iron);

                    // Check inventory for payment
                    if (needDiamond > 0) {
                        int haveDiamond = countMaterial(player, Material.DIAMOND);
                        if (haveDiamond < needDiamond) {
                            Component req = itemStackToComponent(new ItemStack(Material.DIAMOND, needDiamond));
                            player.sendMessage(Component.text("この遺留品を受け取るには", NamedTextColor.RED)
                                .append(req)
                                .append(Component.text("を支払うか、該当する「遺留品の記録」が必要です", NamedTextColor.RED)));
                            return true;
                        }
                    }
                    if (needIron > 0) {
                        int haveIron = countMaterial(player, Material.IRON_INGOT);
                        if (haveIron < needIron) {
                            Component req = itemStackToComponent(new ItemStack(Material.IRON_INGOT, needIron));
                            player.sendMessage(Component.text("この遺留品を受け取るには", NamedTextColor.RED)
                                .append(req)
                                .append(Component.text("を支払うか、該当する「遺留品の記録」が必要です", NamedTextColor.RED)));
                            return true;
                        }
                    }

                    // Withdraw payment
                    Material paidMat = null;
                    int paidAmount = 0;
                    if (needDiamond > 0) {
                        removeMaterial(player, Material.DIAMOND, needDiamond);
                        paidMat = Material.DIAMOND;
                        paidAmount = needDiamond;
                    }
                    if (needIron > 0) {
                        removeMaterial(player, Material.IRON_INGOT, needIron);
                        paidMat = Material.IRON_INGOT;
                        paidAmount = needIron;
                    }

                    List<ItemStack> drops = state.takeAndRemove(deathIdArg);
                    if (drops == null) {
                        player.sendMessage("該当する死亡記録が見つかりません: " + deathIdArg);
                        return true;
                    }
                    int total = 0;
                    for (ItemStack item : drops) {
                        if (item == null) continue;
                        total += item.getAmount();
                        Map<Integer, ItemStack> leftover = player.getInventory().addItem(item);
                        if (!leftover.isEmpty()) {
                            for (ItemStack remain : leftover.values()) {
                                if (remain == null) continue;
                                player.getWorld().dropItemNaturally(player.getLocation(), remain);
                            }
                        }
                    }
                    // Save refund info if payment was made (and record wasn't used)
                    if (!usedRecord && paidMat != null && paidAmount > 0) {
                        state.saveRefund(deathIdArg, new ItemStack(paidMat, paidAmount));
                    }
                    Component paidComp;
                    if (usedRecord) {
                        paidComp = Component.text("「遺留品の記録」を使用しました。", NamedTextColor.GRAY);
                    } else if (needDiamond > 0) {
                        paidComp = materialName(Material.DIAMOND).append(Component.text("×" + needDiamond + " を支払いました。"));
                    } else if (needIron > 0) {
                        paidComp = materialName(Material.IRON_INGOT).append(Component.text("×" + needIron + " を支払いました。"));
                    } else {
                        paidComp = Component.text("コストなし。", NamedTextColor.GRAY);
                    }
                    player.sendMessage(Component.text("取り出し完了: 合計 " + total + " 個のアイテム。")
                        .append(paidComp)
                        .append(Component.text(" 入りきらない分は足元にドロップしました。")));
                    return true;
                }
            default:
                player.sendMessage("使い方: /" + label + " on | off | list | take <deathId>");
                return true;
        }
    }

    @Override
    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
        if (!"preserveinventory".equalsIgnoreCase(command.getName())) {
            return null;
        }
        if (args.length == 1) {
            List<String> c = new ArrayList<>();
            String prefix = args[0].toLowerCase();
            if ("on".startsWith(prefix)) c.add("on");
            if ("off".startsWith(prefix)) c.add("off");
            if ("list".startsWith(prefix)) c.add("list");
            if ("take".startsWith(prefix)) c.add("take");
            return c;
        }
        if (args.length == 2 && "take".equalsIgnoreCase(args[0]) && sender instanceof Player) {
            Player player = (Player) sender;
            String prefix = args[1].toLowerCase();
            List<String> c = new ArrayList<>();
            for (String id : getPlayerState(player).listDeathIds()) {
                if (id.toLowerCase().startsWith(prefix)) c.add(id);
            }
            return c;
        }
        return List.of();
    }

    @EventHandler
    public void onItemSpawn(ItemSpawnEvent event) {
        Item item = event.getEntity();
        ItemStack stack = item.getItemStack();
        if (stack == null) return;
        ItemMeta meta = stack.getItemMeta();
        if (meta == null) return;
        PersistentDataContainer pdc = meta.getPersistentDataContainer();
        if (pdc.has(keyRecordDeathId, PersistentDataType.STRING) && pdc.has(keyRecordOwner, PersistentDataType.STRING)) {
            item.setInvulnerable(true);
            item.setUnlimitedLifetime(true);
        }
    }

    @EventHandler
    public void onPlayerDropItem(PlayerDropItemEvent event) {
        Item item = event.getItemDrop();
        ItemStack stack = item.getItemStack();
        if (stack == null) return;
        ItemMeta meta = stack.getItemMeta();
        if (meta == null) return;
        PersistentDataContainer pdc = meta.getPersistentDataContainer();
        if (pdc.has(keyRecordDeathId, PersistentDataType.STRING) && pdc.has(keyRecordOwner, PersistentDataType.STRING)) {
            item.setInvulnerable(true);
            item.setUnlimitedLifetime(true);
        }
    }

    // Prevent using the record item in crafting (e.g., duplicating a written book)
    @EventHandler
    public void onPrepareCraft(PrepareItemCraftEvent event) {
        for (ItemStack ingredient : event.getInventory().getMatrix()) {
            if (isRecordItem(ingredient)) {
                event.getInventory().setResult(new ItemStack(Material.AIR));
                return;
            }
        }
    }

    @EventHandler
    public void onCraftItem(CraftItemEvent event) {
        for (ItemStack ingredient : event.getInventory().getMatrix()) {
            if (isRecordItem(ingredient)) {
                event.setCancelled(true);
                if (event.getWhoClicked() instanceof Player p) {
                    p.sendMessage("このアイテムはクラフトに使用できません。");
                }
                return;
            }
        }
    }

    // Prevent using the record item in villager trades
    @EventHandler
    public void onMerchantClick(InventoryClickEvent event) {
        if (event.getView().getTopInventory() == null) return;
        if (event.getView().getTopInventory().getType() != InventoryType.MERCHANT) return;
        ItemStack cursor = event.getCursor();
        ItemStack current = event.getCurrentItem();
        if (isRecordItem(cursor) || isRecordItem(current)) {
            event.setCancelled(true);
            if (event.getWhoClicked() instanceof Player p) {
                p.sendMessage("このアイテムは取引に使用できません。");
            }
        }
    }

    @EventHandler
    public void onPlayerDeath(PlayerDeathEvent event) {
        Player player = event.getEntity();
        PlayerState state = getPlayerState(player);
        if (!state.isEnabled()) {
            return;
        }

        // Compute cost for this death
        PlayerState.Cost cost = PlayerState.computeCost(event.getDrops());

        // If total cost is 0, do not preserve; drop as vanilla
        if (cost.total() == 0) {
            // Inform player that nothing will be preserved due to zero cost with coordinates
            Location loc = player.getLocation();
            int x = (int) Math.round(loc.getX());
            int y = (int) Math.round(loc.getY());
            int z = (int) Math.round(loc.getZ());
            player.sendMessage(Component.text(
                "ドロップしたアイテムのコストが0のため、遺留品は回収されませんでした (x" + x + ", y" + y + ", z" + z + ")",
                NamedTextColor.GRAY
            ));
            return;
        }

        // Save snapshot with UUID death ID (including cost)
        String deathId = UUID.randomUUID().toString();
        state.saveDeathSnapshot(deathId, player.getLocation(), event.getDrops());

        // Prevent item drops (they are preserved instead)
        event.getDrops().clear();

        // Drop a "遺留品の記録" at death location
        ItemStack record = createRecordItem(player, deathId, player.getLocation());
        World world = player.getWorld();
        Item dropped = world.dropItem(player.getLocation(), record);
        // Make it resilient to lava/explosions and not despawn
        dropped.setInvulnerable(true);
        dropped.setUnlimitedLifetime(true);
    }

    @EventHandler
    public void onJoin(PlayerJoinEvent event) {
        Player player = event.getPlayer();
        boolean enabled = getPlayerState(player).isEnabled();
        player.sendMessage(enabled ? "PreserveInventoryが有効になっています。" : "PreserveInventoryが無効になっています。");
        player.sendMessage("/preserveinventory on | off で切り替えできます。");
        sendPendingInfo(player);
    }

    @EventHandler
    public void onRespawn(PlayerRespawnEvent event) {
        Player player = event.getPlayer();
        sendPendingInfo(player);
    }

    // --- Helpers for list formatting ---
    private static final DateTimeFormatter TS_FMT = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss").withZone(ZoneId.of("Asia/Tokyo"));

    private String formatTimestamp(String iso) {
        try {
            return TS_FMT.format(Instant.parse(iso));
        } catch (Exception e) {
            return iso;
        }
    }

    private Component summarizeDropsComponent(List<ItemStack> drops) {
        List<Component> parts = new ArrayList<>();
        for (ItemStack it : drops) {
            if (it == null || it.getType() == Material.AIR) continue;
            parts.add(itemStackToComponent(it));
        }
        if (parts.isEmpty()) {
            return Component.text("(なし)");
        }
        return Component.join(JoinConfiguration.separator(Component.text(", ", NamedTextColor.GRAY)), parts);
    }

    private Component itemStackToComponent(ItemStack it) {
        ItemMeta meta = it.getItemMeta();
        Component nameComp = null;
        if (meta != null && meta.hasDisplayName()) {
            nameComp = meta.displayName();
            if (nameComp != null) {
                nameComp = nameComp.color(NamedTextColor.WHITE).decorate(TextDecoration.ITALIC);
            }
        }
        if (nameComp == null) {
            String translationKey = it.getType().translationKey();
            nameComp = Component.translatable(translationKey)
                .color(NamedTextColor.WHITE)
                .decoration(TextDecoration.ITALIC, false);
        }

        return nameComp.hoverEvent(it.asHoverEvent()).append(Component.text("×" + it.getAmount(), NamedTextColor.GRAY));
    }

    private void sendPendingInfo(Player player) {
        List<String> list = getPlayerState(player).listDeathIds();
        int pending = list.size();
        if (pending > 0) {
            Component btn = Component.text("[一覧を見る]")
                .color(NamedTextColor.GREEN)
                .decorate(TextDecoration.BOLD)
                .clickEvent(ClickEvent.runCommand("/preserveinventory list"))
                .hoverEvent(HoverEvent.showText(Component.text("クリックして一覧を表示", NamedTextColor.YELLOW)));
            Component msg = Component.text("未受け取りの遺留品が " + pending + " 件あります。", NamedTextColor.YELLOW);
            player.sendMessage(Component.empty().append(btn).append(Component.text(" ")).append(msg));
        } else {
            player.sendMessage(Component.text("未受け取りの遺留品はありません。", NamedTextColor.GRAY));
        }
    }

    private Component materialName(Material m) {
        String key = m.translationKey();
        return Component.translatable(key)
            .color(NamedTextColor.WHITE)
            .decoration(TextDecoration.ITALIC, false);
    }

    // --- "遺留品の記録" helpers ---
    private boolean isRecordItem(ItemStack stack) {
        if (stack == null) return false;
        if (stack.getType() != Material.WRITTEN_BOOK) return false;
        ItemMeta meta = stack.getItemMeta();
        if (meta == null) return false;
        PersistentDataContainer pdc = meta.getPersistentDataContainer();
        return pdc.has(keyRecordDeathId, PersistentDataType.STRING) && pdc.has(keyRecordOwner, PersistentDataType.STRING);
    }

    private ItemStack createRecordItem(Player owner, String deathId, Location loc) {
        ItemStack book = new ItemStack(Material.WRITTEN_BOOK, 1);
        BookMeta meta = (BookMeta) book.getItemMeta();
        meta.setTitle("遺留品の記録");
        meta.setAuthor(owner.getName());
        String ts = TS_FMT.format(Instant.now());
        String world = (loc.getWorld() != null) ? loc.getWorld().getName() : "unknown";
        int x = (int) Math.round(loc.getX());
        int y = (int) Math.round(loc.getY());
        int z = (int) Math.round(loc.getZ());

        // Owner component with hover to show entity info (black text for readability)
        Component ownerComp = Component.text(owner.getName(), NamedTextColor.BLACK)
            .decoration(TextDecoration.ITALIC, false)
            .hoverEvent(HoverEvent.showEntity(HoverEvent.ShowEntity.of(
                Key.key("minecraft:player"), owner.getUniqueId(), Component.text(owner.getName()))));

        // First page: instructions and clickable [受け取る]
        Component takeBtn = Component.text("[受け取る]", NamedTextColor.BLACK)
            .decorate(TextDecoration.BOLD)
            .clickEvent(ClickEvent.runCommand("/preserveinventory take " + deathId))
            .hoverEvent(HoverEvent.showText(Component.text("クリックして受け取る", NamedTextColor.YELLOW)));

        Component page1 = Component.empty()
            .append(Component.text("この本は遺留品の記録です。\n\n", NamedTextColor.BLACK))
            .append(Component.text("所有者: ", NamedTextColor.BLACK))
            .append(ownerComp)
            .append(Component.text("\n\nこの本がインベントリの中にある状態で、", NamedTextColor.BLACK))
            .append(takeBtn)
            .append(Component.text(" を押すと、コストなしで遺留品を受け取れます。", NamedTextColor.BLACK));

        // Second page: details
        Component page2 = Component.empty()
            .append(Component.text("詳細情報\n\n", NamedTextColor.BLACK))
            .append(Component.text("死亡ID: ", NamedTextColor.BLACK))
            .append(Component.text(deathId, NamedTextColor.BLACK))
            .append(Component.text("\n日時: ", NamedTextColor.BLACK))
            .append(Component.text(ts, NamedTextColor.BLACK))
            .append(Component.text("\n場所: ", NamedTextColor.BLACK))
            .append(Component.text(world + " (" + x + ", " + y + ", " + z + ")", NamedTextColor.BLACK));

        meta.addPages(page1, page2);

        PersistentDataContainer pdc = meta.getPersistentDataContainer();
        pdc.set(keyRecordDeathId, PersistentDataType.STRING, deathId);
        pdc.set(keyRecordOwner, PersistentDataType.STRING, owner.getUniqueId().toString());

        meta.displayName(Component.text("遺留品の記録", NamedTextColor.LIGHT_PURPLE).decoration(TextDecoration.ITALIC, false));
        book.setItemMeta(meta);
        return book;
    }

    private boolean hasRecordFor(Player player, String deathId) {
        for (ItemStack stack : player.getInventory().getContents()) {
            if (stack == null) continue;
            if (stack.getType() != Material.WRITTEN_BOOK) continue;
            ItemMeta meta = stack.getItemMeta();
            if (meta == null) continue;
            PersistentDataContainer pdc = meta.getPersistentDataContainer();
            String did = pdc.get(keyRecordDeathId, PersistentDataType.STRING);
            String owner = pdc.get(keyRecordOwner, PersistentDataType.STRING);
            if (deathId.equals(did) && player.getUniqueId().toString().equals(owner)) {
                return true;
            }
        }
        return false;
    }

    private boolean consumeRecordFor(Player player, String deathId) {
        ItemStack[] contents = player.getInventory().getContents();
        for (int i = 0; i < contents.length; i++) {
            ItemStack stack = contents[i];
            if (stack == null) continue;
            if (stack.getType() != Material.WRITTEN_BOOK) continue;
            ItemMeta meta = stack.getItemMeta();
            if (meta == null) continue;
            PersistentDataContainer pdc = meta.getPersistentDataContainer();
            String did = pdc.get(keyRecordDeathId, PersistentDataType.STRING);
            String owner = pdc.get(keyRecordOwner, PersistentDataType.STRING);
            if (deathId.equals(did) && player.getUniqueId().toString().equals(owner)) {
                int amt = stack.getAmount();
                if (amt <= 1) {
                    contents[i] = null;
                } else {
                    stack.setAmount(amt - 1);
                    contents[i] = stack;
                }
                player.getInventory().setContents(contents);
                return true;
            }
        }
        return false;
    }
    // --- Inventory helpers for payment ---
    private int countMaterial(Player player, Material material) {
        int count = 0;
        for (ItemStack stack : player.getInventory().getContents()) {
            if (stack == null) continue;
            if (stack.getType() == material) {
                count += stack.getAmount();
            }
        }
        return count;
    }

    private void removeMaterial(Player player, Material material, int amount) {
        if (amount <= 0) return;
        ItemStack[] contents = player.getInventory().getContents();
        for (int i = 0; i < contents.length && amount > 0; i++) {
            ItemStack stack = contents[i];
            if (stack == null) continue;
            if (stack.getType() != material) continue;
            int take = Math.min(amount, stack.getAmount());
            stack.setAmount(stack.getAmount() - take);
            amount -= take;
            if (stack.getAmount() <= 0) {
                contents[i] = null;
            }
        }
        player.getInventory().setContents(contents);
    }
}
